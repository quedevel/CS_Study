# SSL / TLS

Created: May 2, 2023 6:33 PM

### SSL (Secure Socket Layer)

- Netscape에서 처음 개발된 웹 서버와 웹 브라우저 간의 암호화 통신을 위해 응용계층과 TCP/IP 계층에서 동작하는 프로토콜
- SSL 3.0 버전에서 보안 결함이 발견되어 안전하지 않다는 평가 받음
⇒ SSL 3.0의 사용이 중단되고 대안으로 TLS가 개발됨

### TLS (Transport Layer Security)

- SSL 3.0버전을 기반으로 하며 현재 TLS 1.3이 최종 버전이며
IETF(Internet Engineering Task Force)에서 표준화되었으며, 국제 표준화 기구(ISO)에서 공식적으로 인증받음
- SSL과 기능적으로 거의 동일하지만 더 많은 암호화 알고리즘과 보안 프로토콜을 지원해 더 강력한 보안 수준을 제공
- SSL에서 TLS로 이름이 변경되었으나 아직 SSL이라는 표현도 많이 사용함
- 기본적으로 인증(Authentication), 암호화(Encryption), 무결성(Integrity)을 지원
    - 인증 : 상대 사이트에 대한 신뢰성 인증
    - 암호화 : 다양한 암호화 알고리즘을 이용해 메시지 암호화
    - 무결성 : 송/수신 메시지에 대한 Checksum 기능, 변조 방지
- 전송 계층에서 암호화를 수행하기 때문에 HTTP 뿐 아니라 FTP, SMTP, POP3, IMAP, XMPP 등 
다른 응용 계층(Application Layer) 프로토콜에서도 사용 가능함

응용 계층에서 발생하는 데이터를 전송 계층으로 보내기 전에 데이터를 암호화하고, 
전송 계층에서 수신한 데이터를 응용 계층에서 사용할 수 있는 형태로 복호화함
    
![Untitled](SSL%20TLS%200459875ad22841f18ddb2b4ec011a0b9/Untitled.png)
    
- 보안 소켓을 설정하기 위해 Handshake Layer와 Record Layer 두 개의 계층으로 구성됨
    - Handshake Layer : 클라이언트와 서버 간의 인증 및 합의 단계
        
        Handshake Layer에서는 다음과 같은 메시지가 교환됨
        
        1. Handshake : 
        클라이언트와 서버 간의 합의를 위한 메시지.
        클라이언트와 서버 간에 서로를 인증하고, SSL/TLS의 버전 및 사용할 암호화 알고리즘 등을 협상하는 데 사용됨
        2. Change CipherSpec : 
        핸드셰이크 과정이 완료되면, 클라이언트와 서버 간에 세션 키를 생성하고, 암호화 알고리즘을 변경함 
        이 때 사용되는 메시지가 Change CipherSpec
        3. Alert: 
        SSL/TLS 연결 중에 발생한 오류 또는 경고를 통보하기 위한 메시지. 예를 들어, 암호화 오류, 인증서 오류 등이 있음
    - Record Layer : Handshake Layer에서 합의된 암호화 알고리즘을 사용하여 데이터를 암호화하고, 전송하는 계층
        
        Record Layer에서는 다음과 같은 메시지가 처리됨
        
        1. Record:
        Handshake Layer에서 합의된 암호화 알고리즘을 사용하여 데이터를 암호화하고 전송함. 
        Record Layer는 SSL/TLS 세션에서 실제 데이터를 보호하는데 사용됨
        2. Alert : 
        Record Layer에서도 Alert 메시지가 존재함
        Handshake Layer에서와 마찬가지로 SSL/TLS 연결 중에 발생한 오류 또는 경고를 통보하기 위해 사용됨
- HTTS = Hypertext Transfer Protocol Over Secure Socket Layer
SSL을 적용하여 보안을 강화한 HTTP.
SSL 인증서 적용이 된 도메인만이 “https://” 주소를 갖을 수 있음
- 안전하고 신뢰성 있는 통신을 제공해 
사용자의 개인 정보나 중요한 정보를 보호하고, 불법적인 접근과 공격으로부터 안전하게 지킴

---

## 암호화 방식

SSL/TLS에서는 대칭키 암호화 방식과 공개키 암호화 방식을 혼용해서 사용.
대칭키 암호화 방식의 빠른 속도와 공개키 암호화 방식의 높은 보안성을 모두 활용해서 안전하고 신뢰성 있는 통신을 제공함

- 서버와 주고 받는 데이터 ⇒ 대칭키 방식으로 암호화
- 대칭키 방식에 사용된 key ⇒ 내 서버의 공개키로 암호화

1. 대칭키 방식
    - 암호화/복호화 시 동일한 1개의 key를 사용
    - 빠르지만 보안성 취약
    - TLS/SSL에서는 대칭키 암호화 방식으로 RC4, AES, DES, 3DES 등을 사용함 
    TLS/SSL 핸드셰이크에서 클라이언트와 서버가 서로 동일한 비밀키를 공유할 수 있도록 함
        - RC4(암호화 알고리즘): 가볍고 빠르기 때문에 웹 상에서 가장 많이 사용되는 대칭키 암호화 방식 중 하나. 현재는 일부 취약점이 발견되어 권장하지 않음
        - AES(Advanced Encryption Standard): 대칭키 암호화 방식 중 가장 안전한 방식. 128비트, 192비트, 256비트의 키 길이를 지원하며, TLS/SSL에서 가장 많이 사용됨
        - DES(Data Encryption Standard): 오래된 대칭키 암호화 방식 중 하나. 56비트의 키 길이를 지원하며, 현재는 보안성이 취약해 권장되지 않음
        - 3DES(Triple DES): DES를 세 번 반복해 DES의 보안성을 향상시킨 대칭키 암호화 방식. 168비트의 키 길이를 지원. but AES와 비교해 느리고, 복잡하며, 안전성이 낮아 권장되지 않음
    
2. 공개키 방식
    - 서로 다른 2개의 키를 사용해 암호화/복호화를 수행
    (서버만 소유하는 Private Key, 브라우저에게 나눠주는 Publick Key)
    공개키로 암호화한 데이터는 비밀키로 복호화 가능하며, 비밀키로 암호화한 데이터는 공개키로 복호화 가능
    - 느리지만 보안성 높음
    - TLS/SSL에서는 공개키 암호화 방식으로 RSA, DSA, ECDH 등을 사용함
    클라이언트는 서버의 공개키를 이용해 암호화된 데이터를 서버에게 전송하고, 서버는 자신의 개인키를 이용하여 암호화된 데이터를 복호화함
        - RSA(Rivest–Shamir–Adleman): 가장 보편적으로 사용되는 방식 중 하나. 수학적으로 복잡한 연산 기반. 공개키와 개인키를 사용해 데이터를 암호화/복호화
        - DSA(Digital Signature Algorithm): 전자 서명에 사용되는 방식. RSA처럼 수학적으로 복잡한 연산 기반. 서명에 사용되는 개인키와 검증에 사용되는 공개키를 사용함
        - ECDH(Elliptic Curve Diffie-Hellman): 공개키를 기반으로 한 키 교환 프로토콜 중 하나. 타원 곡선 암호학(Elliptic Curve Cryptography)을 사용해 키 교환 수행. 
        RSA와 비교해 키 길이가 짧고, 암호화 연산이 빠르며, 보안성이 높음
    - ex ) 로그인 : 브라우저에서 ID/PW를 공개키로 암호화해서 전송 → 서버는 비밀키로 복호화해 로그인 처리

---

## TLS/SSL 과정

### SSL 인증서 생성

1. 서버에서 ‘비밀키/공개키’를 생성
2. ‘서버 공개키’를 공인기관(CA)에 전달하면서 ‘SSL 인증서’ 발급 요청
3. CA는 ‘CA 비밀키로 암호화된 인증서’ 발급 
    - CA의 정보 (발급자)
    - 서버의 정보 (도메인, 서버 공개키 등)
4. 내 서버에 SSL 인증서를 저장하고 SSL 통신을 설정해둠

### Handshake : 클라이언트와 서버가 통신을 위해 서로의 신원을 인증하고 암호화 키를 교환

![Untitled](SSL%20TLS%200459875ad22841f18ddb2b4ec011a0b9/Untitled%201.png)

1. 클라이언트가 서버에 연결 시도
    - 클라이언트가 서버에게 [클라이언트가 지원하는 SSL/TLS 버전, 지원하는 암호화 알고리즘, 클라이언트에서 생성한 랜덤 데이터]를 전송
2. 서버가 클라이언트에 응답
    - 클라이언트로부터 받은 SSL/TLS 버전과, 암호화 알고리즘 등을 확인
    - 사용 가능한 알고리즘이 있을 경우 그 중 하나를 선택 (=서로 암호화 방식 맞추기)
    - 서버는 클라이언트에게 [서버의 SSL 인증서, 선택한 암호화 알고리즘, 서버에서 생성한 랜덤 데이터]를 전송
3. 클라이언트의 인증 작업
    - 서버에게 받은 SSL 인증서 확인
        - 인증서를 ‘CA의 공개키’로 복호화
            
            인증서는 ‘발급한 CA의 비밀키’로 암호화 되어있으며,
            클라이언트(브라우저)는 ‘공인된 CA들의 공개키’를 내부에 보관하고 있음
            
        - 인증서 복호화에 성공 시 해당 인증서가 CA가 발급한 것임이 증명됨 = CA가 인증한 서버임을 인식
        - 인증서에 표시된 도메인과 서버 실제 도메인이 일치하는지 검증
    - 인증서에 대한 신뢰성 확보 시 복호화된 인증서의 '서버 공개키' 획득
4. 클라이언트가 서버에게 'pre master secret key' 키 전달]
    - 클라이언트는 클라이언트의 랜덤 데이터를 서버의 공개키를 사용해 암호화해서 서버에게 전송
5. 'session key' 생성
    - 클라이언트-서버는 데이터를 주고 받을 때, session key를 통해 '대칭키 방식'으로 암호화하여 통신
    - 클라이언트와 서버가 모두 [클라이언트 무작위, 서버 무작위, 예비 마스터 암호]를 이용해 세션 키를 생성 (모두 같은 결과가 나와야함)
        - 서버는 클라이언트가 보낸 pre master secret key 수신하고 개인키를 사용해 암호화된 랜덤 데이터 복호화
        - 클라이언트가 보낸 랜덤 데이터와 서버의 랜덤 데이터를 결합해 마스터 비밀키 생성
        - 클라이언트에게 서버에서 사용할 암호화 키를 생성하기 위한 정보를 보냄
        - 클라이언트는 자신의 개인키를 사용해 서버가 보낸 정보를 복호화하고 마스터 비밀키를 생성
        - 클라이언트와 서버는 마스터 비밀키를 사용해 통신에 사용할 대칭 키(세션 키) 생성
6. 클라이언트 준비 완료 : 클라이언트가 세션 키로 암호화된 "완료" 메시지를 전송
7. 서버 준비 완료 : 서버가 세션 키로 암호화된 "완료" 메시지를 전송
8. 핸드쉐이크 완료
    - 서버의 신원 확인 완료
    - 서버와 클라이언트는 암호화 통신에 필요한 대칭 키 서로 보유

### **세션(전송): 실제로 서버와 클라이언트가 데이터를 주고 받는 단계**

- 핸드셰이크 과정에서 교환한 암호화 키를 사용해 클라언트와 서버 간의 모든 통신을 암호화함
- 이를 통해 제 3자가 통신 내용을 엿볼 수 없음

1. 클라이언트의 데이터 암호화/전송
    - 'session key'를 통해 대칭키 방식으로 '데이터를 암호화'해 서버에 전송
2. 서버의 데이터 복호화
    - 'session key'를 통해 대칭키 방식으로 '데이터를 복호화'해 처리
    - 'session key'를 통해 대칭키 방식으로' 응답 데이터를 암호화'해 클라이언트에 전송
3. 클라이언트의 데이터 복호화
    - 'session key'를 통해 대칭키 방식으로 '데이터를 복호화'해 처리

### 인증서 갱신

- 디지털 인증서는 일정 기간 지나면 만료되므로 필요한 경우 TLS/SSL은 인증서의 갱신을 지원하며 보안성을 유지함

### **세션 종료**

1. 데이터 전송 종료
2. SSL 통신 종료
3. 'session key' 폐기
    
    매번 연결 시마다 새로운 session key를 생성해 짧은 시간만 사용하기 때문에 탈취되더라도 비교적 안전함
    

---

## 주체별 공개키/비밀키의 보유

1. CA(인증기관)
    - `CA의 비밀키` 보유
    - SSL인증서 암호화에 사용
2. SSL인증서
    - `내 서버의 공개키` 저장
    - 브라우저-서버 통신 데이터 암호화에 할용
3. 브라우저:
    - 다양한 `CA들의 공개키` 보유
    - SSL 인증서 복호화에 사용
4. 내 서버
    - `내 서버의 비밀키` 보유
    - 브라우저-서버 통신 데이터 암호화에 할용
    

### Reference

- [https://aws-hyoh.tistory.com/39](https://aws-hyoh.tistory.com/39)
- [https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/](https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/)
- [http://www.ktword.co.kr/test/view/view.php?m_temp1=2552](http://www.ktword.co.kr/test/view/view.php?m_temp1=2552)
- [https://gyoogle.dev/blog/computer-science/network/TLS HandShake.html](https://gyoogle.dev/blog/computer-science/network/TLS%20HandShake.html)
- [https://curryyou.tistory.com/207](https://curryyou.tistory.com/207)
